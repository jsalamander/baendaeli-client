<!doctype html>
<html lang="en" data-theme="dark">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Baendae.li Payment</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.20/dist/full.min.css" rel="stylesheet" type="text/css" />
	<style>
		.dot {
			width: 12px;
			height: 12px;
			border-radius: 999px;
			background: #7ce7c1;
			box-shadow: 0 0 0 rgba(124, 231, 193, 0.4);
			animation: pulse 1.2s ease-in-out infinite;
			display: inline-block;
		}
		@keyframes pulse {
			0% { box-shadow: 0 0 0 0 rgba(124, 231, 193, 0.35); }
			70% { box-shadow: 0 0 0 16px rgba(124, 231, 193, 0); }
			100% { box-shadow: 0 0 0 0 rgba(124, 231, 193, 0); }
		}
		.hidden { display: none; }
	</style>
</head>
<body class="flex flex-col min-h-screen bg-base-900">
	<!-- Navbar -->
	<nav class="navbar bg-base-800 border-b border-base-700">
		<div class="flex-1">
			<a class="btn btn-ghost text-xl" href="/">Bändäli Outomat</a>
		</div>
	</nav>

	<!-- Main Content -->
	<main class="flex-1 flex items-center justify-center p-4">
		<div class="card bg-base-800 border border-base-700 shadow-xl w-full max-w-md">
			<div class="card-body">
				<!-- Success Banner (hidden by default) -->
				<div class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur" id="successBanner">
					<div class="alert alert-success alert-lg shadow-lg max-w-sm">
						<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
						<span class="font-bold">Danke, dein Solibändeli wird ausgegeben!</span>
					</div>
				</div>

				<h2 class="card-title text-2xl">Bändäli Outomat</h2>
				<p class="text-base-content/70">Scanne den QR-Code mit deinem Smartphone, um das Solibändeli zu bezahlen.</p>

				<!-- Status Badge -->
				<div class="badge badge-lg gap-2 badge-info" id="status">
					<span class="dot"></span>
					<span>Wait: creating payment...</span>
				</div>

				<!-- QR Code Display -->
				<div class="bg-base-700 rounded-lg border border-dashed border-base-600 p-4 flex items-center justify-center min-h-[220px]" id="qr">
					<div class="text-center">
						<svg class="inline-block w-8 h-8 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
							<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
							<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
						</svg>
						<p class="mt-2 text-sm">Warten auf QR Code...</p>
					</div>
				</div>

				<!-- Error Message -->
				<div class="alert alert-error hidden" id="errorContainer">
					<svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l-2-2m0 0l-2-2m2 2l2-2m-2 2l-2 2" /></svg>
					<span id="error"></span>
				</div>

				<!-- Retry Button -->
				<button class="btn btn-primary w-full hidden" id="retry">Try again</button>

				<!-- Diagnostics -->
				<div class="divider my-2"></div>
				<div class="space-y-2 text-sm">
					<div class="flex items-center justify-between">
						<div class="flex items-center gap-2">
							<div class="w-2 h-2 rounded-full bg-warning" id="gatewayDot"></div>
							<span id="gatewayStatusText">Gateway wird geprüft...</span>
						</div>
					</div>
					<div class="flex items-center justify-between text-xs text-base-content/60">
						<span id="gatewayMeta">Warte auf erste Antwort</span>
						<span id="expiryMeta">Gültig für --:--</span>
					</div>
				</div>
			</div>
		</div>
	</main>

	<!-- Payment ID Badge (fixed position) -->
	<div class="fixed bottom-4 right-4 badge badge-outline hidden" id="paymentId"></div>

	<!-- Footer -->
	<footer class="footer footer-center bg-base-800 border-t border-base-700 p-4 text-base-content/70">
		<div>
			<p class="text-sm">© 2026 Baendae.li. All rights reserved.</p>
		</div>
	</footer>

	<script>
		const statusEl = document.getElementById('status');
		const qrEl = document.getElementById('qr');
		const errorEl = document.getElementById('error');
		const errorContainer = document.getElementById('errorContainer');
		const retryBtn = document.getElementById('retry');
		const paymentIdEl = document.getElementById('paymentId');
		const successBanner = document.getElementById('successBanner');
		const gatewayDot = document.getElementById('gatewayDot');
		const gatewayStatusText = document.getElementById('gatewayStatusText');
		const gatewayMeta = document.getElementById('gatewayMeta');
		const expiryMeta = document.getElementById('expiryMeta');
		const defaultAmount = {{ .DefaultAmount }};
		const successOverlayMs = {{ .SuccessOverlayMs }};
		let pollTimer = null;
		let currentPaymentId = null;
		let lastDiagnosticsState = 'pending';
		let lastDiagnosticsTime = null;
		let lastDiagnosticsLatency = null;
		let expiryAt = null;
		let expiryTimer = null;

		retryBtn.addEventListener('click', () => {
			retryBtn.classList.add('hidden');
			errorEl.textContent = '';
			errorContainer.classList.add('hidden');
			qrEl.innerHTML = '<div class="text-center"><svg class="inline-block w-8 h-8 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><p class="mt-2 text-sm">Warten auf QR Code...</p></div>';
			paymentIdEl.classList.add('hidden');
			clearPoll();
			clearExpiry();
			start();
		});

		function clearExpiry() {
			if (expiryTimer) {
				clearInterval(expiryTimer);
				expiryTimer = null;
			}
			expiryAt = null;
			expiryMeta.textContent = 'Gültig für --:--';
		}

		function startExpiryCountdown(expiresAtString, validForMinutes) {
			clearExpiry();
			let target = null;
			if (expiresAtString) {
				const parsed = Date.parse(expiresAtString);
				if (!Number.isNaN(parsed)) {
					target = parsed;
				}
			}
			if (!target && validForMinutes) {
				target = Date.now() + Math.max(0, validForMinutes) * 60_000;
			}
			if (!target) return;
			expiryAt = target;
			updateExpiryCountdown();
			expiryTimer = setInterval(updateExpiryCountdown, 1000);
		}

		function updateExpiryCountdown() {
			if (!expiryAt) return;
			const remaining = expiryAt - Date.now();
			if (remaining <= 0) {
				clearExpiry();
				start();
				return;
			}
			const mins = Math.floor(remaining / 60_000);
			const secs = Math.floor((remaining % 60_000) / 1_000);
			expiryMeta.textContent = 'Gültig für ' + String(mins).padStart(2, '0') + ':' + String(secs).padStart(2, '0');
		}

		function setDiagnosticsPending() {
			lastDiagnosticsState = 'pending';
			lastDiagnosticsTime = null;
			lastDiagnosticsLatency = null;
			gatewayDot.className = 'w-2 h-2 rounded-full bg-warning';
			gatewayStatusText.textContent = 'Gateway wird geprüft...';
			gatewayMeta.textContent = 'Warte auf erste Antwort';
			expiryMeta.textContent = 'Gültig für --:--';
		}

		function updateDiagnostics({ ok, latencyMs, at }) {
			lastDiagnosticsState = ok ? 'ok' : 'bad';
			lastDiagnosticsTime = at || Date.now();
			lastDiagnosticsLatency = latencyMs != null ? Math.max(0, Math.round(latencyMs)) : null;

			if (ok) {
				gatewayDot.className = 'w-2 h-2 rounded-full bg-success';
				gatewayStatusText.textContent = 'Gateway: OK';
				const latencyText = lastDiagnosticsLatency != null ? lastDiagnosticsLatency + ' ms' : '—';
				gatewayMeta.textContent = 'Zuletzt: ' + formatTime(lastDiagnosticsTime) + ' · Latenz: ' + latencyText;
			} else {
				gatewayDot.className = 'w-2 h-2 rounded-full bg-error';
				gatewayStatusText.textContent = 'Gateway: gestört';
				gatewayMeta.textContent = 'Letzter Versuch: ' + formatTime(lastDiagnosticsTime);
			}
		}

		function formatTime(ts) {
			if (!ts) return '-';
			try {
				return new Date(ts).toLocaleTimeString('de-CH', { hour12: false });
			} catch {
				return '-';
			}
		}

		setDiagnosticsPending();

		function clearPoll() {
			if (pollTimer) {
				clearTimeout(pollTimer);
				pollTimer = null;
			}
		}

		async function safeParseJson(res) {
			const text = await res.text();
			try {
				return { data: JSON.parse(text), raw: text };
			} catch {
				return { data: {}, raw: text };
			}
		}

		async function start() {
			statusEl.innerHTML = '<span class="dot"></span><span>Wait: creating payment...</span>';
			statusEl.className = 'badge badge-lg gap-2 badge-info';
			paymentIdEl.classList.add('hidden');
			errorEl.textContent = '';
			errorContainer.classList.add('hidden');
			successBanner.classList.add('hidden');
			qrEl.classList.remove('hidden');
			clearPoll();
			clearExpiry();
			setDiagnosticsPending();
			try {
				const res = await fetch('/api/payment', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						amount_cents: defaultAmount,
						currency: 'CHF',
						payment_redirect_url: 'https://example.com/payments/123/complete'
					})
				});

				const { data } = await safeParseJson(res);

				if (!res.ok) {
					throw new Error(data.error || 'Payment creation failed');
				}

				statusEl.innerHTML = '<span class="dot"></span><span>Payment created</span>';
				if (data.id) {
					paymentIdEl.textContent = 'ID ' + data.id;
					paymentIdEl.classList.remove('hidden');
					currentPaymentId = data.id;
					pollStatus(data.id);
				}
				startExpiryCountdown(data.expires_at, data.valid_for_minutes);
				renderQr(data);
			} catch (err) {
				console.error('Payment creation failed', err);
				statusEl.innerHTML = '<span class="dot"></span><span>Etwas ist schiefgelaufen.</span>';
				statusEl.className = 'badge badge-lg gap-2 badge-error';
				errorEl.textContent = 'Die Zahlung konnte nicht gestartet werden. Bitte versuche es erneut.';
				errorContainer.classList.remove('hidden');
				retryBtn.classList.remove('hidden');
			}
		}

		async function pollStatus(id) {
			if (!id) return;
			clearPoll();
			const attemptStarted = performance.now();
			let diagUpdated = false;
			try {
				const res = await fetch('/api/payment/' + encodeURIComponent(id));
				const latencyMs = Math.round(performance.now() - attemptStarted);
				const timestamp = Date.now();
				const { data } = await safeParseJson(res);

				if (!res.ok) {
					updateDiagnostics({ ok: false, latencyMs, at: timestamp });
					diagUpdated = true;
					throw new Error(data.error || 'Status check failed');
				}

				updateDiagnostics({ ok: true, latencyMs, at: timestamp });
				diagUpdated = true;
				errorEl.textContent = '';
				errorContainer.classList.add('hidden');

				const status = (data.status || '').toLowerCase();
				switch (status) {
					case 'waiting':
						statusEl.innerHTML = '<span class="dot"></span><span>Warten auf Zahlung...</span>';
						statusEl.className = 'badge badge-lg gap-2 badge-info';
						pollTimer = setTimeout(() => pollStatus(id), 2000);
						break;
					case 'success':
						statusEl.innerHTML = '<span class="dot"></span><span>Zahlung erfolgreich</span>';
						statusEl.className = 'badge badge-lg gap-2 badge-success';
						showSuccessThenRestart();
						break;
					case 'failure':
						statusEl.innerHTML = '<span class="dot"></span><span>Zahlung fehlgeschlagen</span>';
						statusEl.className = 'badge badge-lg gap-2 badge-error';
						setTimeout(() => start(), 1200);
						break;
					default:
						statusEl.innerHTML = '<span class="dot"></span><span>Unbekannter Status</span>';
						statusEl.className = 'badge badge-lg gap-2 badge-warning';
						pollTimer = setTimeout(() => pollStatus(id), 3000);
				}
			} catch (err) {
				console.error('Status check failed', err);
				if (!diagUpdated) {
					updateDiagnostics({ ok: false, latencyMs: null, at: Date.now() });
				}
				errorEl.textContent = 'Der Zahlungsstatus konnte nicht geprüft werden. Wir versuchen es gleich erneut.';
				errorContainer.classList.remove('hidden');
				statusEl.innerHTML = '<span class="dot"></span><span>Status wird überprüft...</span>';
				statusEl.className = 'badge badge-lg gap-2 badge-warning';
				pollTimer = setTimeout(() => pollStatus(id), 3000);
			}
		}

		async function showSuccessThenRestart() {
			successBanner.classList.remove('hidden');
			qrEl.classList.add('hidden');
			clearPoll();
			clearExpiry();
			
			let actuatorTimeMs = successOverlayMs;
			
			try {
				const res = await fetch('/api/actuate', { method: 'POST' });
				const { data } = await safeParseJson(res);
				
				if (res.ok && data.total_time_ms) {
					actuatorTimeMs = Math.max(successOverlayMs, data.total_time_ms);
					console.log('Actuator completed in', data.total_time_ms, 'ms');
				} else if (!res.ok) {
					console.error('Actuator error:', data.error);
					errorEl.textContent = data.error || 'Solibändeli konnte nicht ausgegeben werden. Bitte kontaktiere den Betreiber.';
					errorContainer.classList.remove('hidden');
					actuatorTimeMs = 4000;
				}
			} catch (err) {
				console.error('Actuator request failed:', err);
				errorEl.textContent = 'Fehler beim Ausgeben des Solibändeli. Bitte versuche es erneut.';
				errorContainer.classList.remove('hidden');
				actuatorTimeMs = 4000;
			}
			
			setTimeout(() => {
				successBanner.classList.add('hidden');
				errorEl.textContent = '';
				errorContainer.classList.add('hidden');
				start();
			}, actuatorTimeMs);
		}

		function renderQr(data) {
			const svg = data.qr_code_svg || data.qrcode_svg || data.qr_svg || data.twint_qr_code_svg;
			const png = data.qr_code_png_base64 || data.qrcode_png_base64 || data.twint_qr_code_png_base64;
			const url = data.qr_code_url || data.qrcode_url || data.payment_qr_url || data.url;
			const qrData = data.qr || data.qrcode || data.qr_data;

			qrEl.innerHTML = '';

			if (svg && typeof svg === 'string') {
				qrEl.innerHTML = svg;
				return;
			}

			if (png && typeof png === 'string') {
				const img = new Image();
				img.src = 'data:image/png;base64,' + png;
				img.alt = 'Payment QR code';
				qrEl.appendChild(img);
				return;
			}

			if (qrData && typeof qrData === 'string') {
				const trimmed = qrData.trim();
				if (trimmed.startsWith('data:')) {
					const img = new Image();
					img.src = trimmed;
					img.alt = 'Payment QR code';
					qrEl.appendChild(img);
					return;
				}

				if (trimmed.startsWith('<svg')) {
					qrEl.innerHTML = trimmed;
					return;
				}

				const base64Like = /^[A-Za-z0-9+/]+={0,2}$/;
				if (base64Like.test(trimmed)) {
					const img = new Image();
					img.src = 'data:image/png;base64,' + trimmed;
					img.alt = 'Payment QR code';
					qrEl.appendChild(img);
					return;
				}
			}

			if (url && typeof url === 'string') {
				const img = new Image();
				img.src = url;
				img.alt = 'Payment QR code';
				qrEl.appendChild(img);
				return;
			}

			qrEl.textContent = 'No QR code found in the response.';
		}

		start();
	</script>
</body>
</html>
